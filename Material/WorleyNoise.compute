#pragma kernel main2D
#pragma kernel main3D

#define FloatMax 3.402823466e+38f


RWTexture2D<float4> outTex2D;
RWTexture3D<float4> outShapeTex3D;
RWTexture3D<float> outShapePerlinNoiseTex3D;

StructuredBuffer<int2> inMarkPos2D;
StructuredBuffer<int3> inSamplePoint3D0;
StructuredBuffer<int3> inSamplePoint3D1;
StructuredBuffer<int3> inSamplePoint3D2;
StructuredBuffer<int3> inSamplePoint3D3;

int inGridCountArray[4];
int inGridLengthArray[4];
float inGridRateArray[4];

int inResolution;

int inOctave;
float inFrequency;
float inLacunarity;
float inPersistence;

float3 inOffset;
bool inFlip;
int inDimension;

//-------------------------------------
// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20201014 (stegu)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
// 

float3 mod289(float3 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float4 mod289(float4 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float4 permute(float4 x) {
	return mod289(((x * 34.0) + 10.0) * x);
}

float4 taylorInvSqrt(float4 r)
{
	return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(float3 v)
{
	const float2  C = float2(1.0 / 6.0, 1.0 / 3.0);
	const float4  D = float4(0.0, 0.5, 1.0, 2.0);

	// First corner
	float3 i = floor(v + dot(v, C.yyy));
	float3 x0 = v - i + dot(i, C.xxx);

	// Other corners
	float3 g = step(x0.yzx, x0.xyz);
	float3 l = 1.0 - g;
	float3 i1 = min(g.xyz, l.zxy);
	float3 i2 = max(g.xyz, l.zxy);

	//   x0 = x0 - 0.0 + 0.0 * C.xxx;
	//   x1 = x0 - i1  + 1.0 * C.xxx;
	//   x2 = x0 - i2  + 2.0 * C.xxx;
	//   x3 = x0 - 1.0 + 3.0 * C.xxx;
	float3 x1 = x0 - i1 + C.xxx;
	float3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
	float3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

  // Permutations
	i = mod289(i);
	float4 p = permute(permute(permute(
		i.z + float4(0.0, i1.z, i2.z, 1.0))
		+ i.y + float4(0.0, i1.y, i2.y, 1.0))
		+ i.x + float4(0.0, i1.x, i2.x, 1.0));

	// Gradients: 7x7 points over a square, mapped onto an octahedron.
	// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
	float n_ = 0.142857142857; // 1.0/7.0
	float3  ns = n_ * D.wyz - D.xzx;

	float4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

	float4 x_ = floor(j * ns.z);
	float4 y_ = floor(j - 7.0 * x_);    // mod(j,N)

	float4 x = x_ * ns.x + ns.yyyy;
	float4 y = y_ * ns.x + ns.yyyy;
	float4 h = 1.0 - abs(x) - abs(y);

	float4 b0 = float4(x.xy, y.xy);
	float4 b1 = float4(x.zw, y.zw);

	//float4 s0 = float4(lessThan(b0,0.0))*2.0 - 1.0;
	//float4 s1 = float4(lessThan(b1,0.0))*2.0 - 1.0;
	float4 s0 = floor(b0) * 2.0 + 1.0;
	float4 s1 = floor(b1) * 2.0 + 1.0;
	float4 sh = -step(h, 0.0);

	float4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
	float4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

	float3 p0 = float3(a0.xy, h.x);
	float3 p1 = float3(a0.zw, h.y);
	float3 p2 = float3(a1.xy, h.z);
	float3 p3 = float3(a1.zw, h.w);

	//Normalise gradients
	float4 norm = taylorInvSqrt(float4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
	p0 *= norm.x;
	p1 *= norm.y;
	p2 *= norm.z;
	p3 *= norm.w;

	// Mix final noise value
	float4 m = max(0.5 - float4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
	m = m * m;
	return 105.0 * dot(m * m, float4(dot(p0, x0), dot(p1, x1),
		dot(p2, x2), dot(p3, x3)));
}

/*
// demo code:
float color(float3 xyz) { return snoise(xyz); }
void mainImage(out float4 fragColor, in float2 fragCoord) {
	float2 p = (fragCoord.xy / iResolution.y) * 2.0 - 1.0;

	float z_squared = 1.0 - length(p.xy);
	if (z_squared < 0.0) { fragColor = float4(0, 0, 0, 1); return; }
	float3 xyz = float3(p, -sqrt(z_squared));

	float n = color(xyz * 4.0);

	fragColor.xyz = mix(0.0, 0.5 + 0.5 * n, smoothstep(0.0, 0.003, z_squared)) * float3(1, 1, 1);

}
*/

//------------------------------------------------
//
//	Perlin Noise
//
float3 wglnoise_mod289(float3 x)
{
	return x - floor(x / 289) * 289;
}

float4 wglnoise_mod289(float4 x)
{
	return x - floor(x / 289) * 289;
}

float4 wglnoise_permute(float4 x)
{
	return wglnoise_mod289((x * 34 + 1) * x);
}

float3 wglnoise_fade(float3 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float ClassicNoise_impl(float3 pi0, float3 pf0, float3 pi1, float3 pf1)
{
	pi0 = wglnoise_mod289(pi0);
	pi1 = wglnoise_mod289(pi1);

	float4 ix = float4(pi0.x, pi1.x, pi0.x, pi1.x);
	float4 iy = float4(pi0.y, pi0.y, pi1.y, pi1.y);
	float4 iz0 = pi0.z;
	float4 iz1 = pi1.z;

	float4 ixy = wglnoise_permute(wglnoise_permute(ix) + iy);
	float4 ixy0 = wglnoise_permute(ixy + iz0);
	float4 ixy1 = wglnoise_permute(ixy + iz1);

	float4 gx0 = lerp(-1, 1, frac(floor(ixy0 / 7) / 7));
	float4 gy0 = lerp(-1, 1, frac(floor(ixy0 % 7) / 7));
	float4 gz0 = 1 - abs(gx0) - abs(gy0);

	bool4 zn0 = gz0 < -0.01;
	gx0 += zn0 * (gx0 < -0.01 ? 1 : -1);
	gy0 += zn0 * (gy0 < -0.01 ? 1 : -1);

	float4 gx1 = lerp(-1, 1, frac(floor(ixy1 / 7) / 7));
	float4 gy1 = lerp(-1, 1, frac(floor(ixy1 % 7) / 7));
	float4 gz1 = 1 - abs(gx1) - abs(gy1);

	bool4 zn1 = gz1 < -0.01;
	gx1 += zn1 * (gx1 < -0.01 ? 1 : -1);
	gy1 += zn1 * (gy1 < -0.01 ? 1 : -1);

	float3 g000 = normalize(float3(gx0.x, gy0.x, gz0.x));
	float3 g100 = normalize(float3(gx0.y, gy0.y, gz0.y));
	float3 g010 = normalize(float3(gx0.z, gy0.z, gz0.z));
	float3 g110 = normalize(float3(gx0.w, gy0.w, gz0.w));
	float3 g001 = normalize(float3(gx1.x, gy1.x, gz1.x));
	float3 g101 = normalize(float3(gx1.y, gy1.y, gz1.y));
	float3 g011 = normalize(float3(gx1.z, gy1.z, gz1.z));
	float3 g111 = normalize(float3(gx1.w, gy1.w, gz1.w));

	float n000 = dot(g000, pf0);
	float n100 = dot(g100, float3(pf1.x, pf0.y, pf0.z));
	float n010 = dot(g010, float3(pf0.x, pf1.y, pf0.z));
	float n110 = dot(g110, float3(pf1.x, pf1.y, pf0.z));
	float n001 = dot(g001, float3(pf0.x, pf0.y, pf1.z));
	float n101 = dot(g101, float3(pf1.x, pf0.y, pf1.z));
	float n011 = dot(g011, float3(pf0.x, pf1.y, pf1.z));
	float n111 = dot(g111, pf1);

	float3 fade_xyz = wglnoise_fade(pf0);
	float4 n_z = lerp(float4(n000, n100, n010, n110),
		float4(n001, n101, n011, n111), fade_xyz.z);
	float2 n_yz = lerp(n_z.xy, n_z.zw, fade_xyz.y);
	float n_xyz = lerp(n_yz.x, n_yz.y, fade_xyz.x);
	return 1.46 * n_xyz;
}

// Classic Perlin noise
float perlinNoise(float3 p)
{
	float3 i = floor(p);
	float3 f = frac(p);
	return ClassicNoise_impl(i, f, i + 1, f - 1);
}


//-----------------------------------------------------
//
//	2D Worley noise
//
int2 getGridF(float2 pos)
{
	return int2(pos.x / inGridRateArray[0], pos.y / inGridRateArray[0]);
}

void getNeighbour9(in int2 gridPos, out int2 result[9], in int gridCount)
{
	int index = 0;
	float2 offset = 0;

	for (int y = -1; y <= 1; y++)
	{
		for (int x = -1; x <= 1; x++)
		{
			int pos_y = gridPos.y + y;
			int pos_x = gridPos.x + x;
			offset.x = 0;
			offset.y = 0;

			if (pos_x < 0)
			{
				pos_x = gridCount - 1;
				offset.x = -inResolution;
			}

			if (pos_x >= gridCount)
			{
				pos_x = 0;
				offset.x = inResolution;
			}

			if (pos_y < 0)
			{
				pos_y = gridCount - 1;
				offset.y = -inResolution;
			}

			if (pos_y >= gridCount)
			{
				pos_y = 0;
				offset.y = inResolution;
			}

			result[index] = inMarkPos2D[pos_x + pos_y * gridCount] + offset;
			index++;
		}
	}
}

float getCloseDistance(in int2 n9[9], in int2 pos)
{
	float result = FloatMax;

	for (int i = 0; i < 9; i++)
	{
		float dis = distance(n9[i], pos);
		if (dis < result)
		{
			result = dis;
		}
	}

	return result;
}

float getNoiseF(float2 pos)
{
	pos.x = pos.x - (int)pos.x;
	pos.y = pos.y - (int)pos.y;

	if (pos.x < 0.0f)
	{
		pos.x = 1.0f + pos.x;
	}

	if (pos.y < 0.0f)
	{
		pos.y = 1.0f + pos.y;
	}

	int2 grid_pos = getGridF(pos);
	int2 n9[9];
	getNeighbour9(grid_pos, n9, inGridCountArray[0]);

	int2 cp = int2(pos.x * inResolution, pos.y * inResolution);
	return getCloseDistance(n9, cp) / inGridLengthArray[0];
}

[numthreads(8, 8, 1)]
void main2D(uint3 id : SV_DispatchThreadID)
{
	float2 pos = float2(id.x / (float)inResolution - 0.5f, id.y / (float)inResolution - 0.5f);

	float freq = inFrequency;
	float strength = 1.0f;
	float sum_strength = strength;

	float noise = getNoiseF(pos * freq + float2(inOffset.x, inOffset.y));

	for (int o = 1; o < inOctave; o++)
	{
		freq *= inLacunarity;
		strength *= inPersistence;
		sum_strength += strength;
		noise += getNoiseF(pos * freq + float2(inOffset.x, inOffset.y)) * strength;
	}

	noise /= sum_strength;

	if (inFlip)
	{
		noise = 1.0f - noise;
	}

	outTex2D[id.xy] = float4(noise, noise, noise, 1.0f);
}

//-----------------------------------------------------
//
//	3D
//
int3 getGridF(in float3 pos, in float rate)
{
	return int3(pos.x / rate, pos.y / rate, pos.z / rate);
}

void getNeighbour27(in StructuredBuffer<int3> samplePoints, in int3 gridPos, in int gridCount, out int3 result[27])
{
	int index = 0;
	int offset_z = gridCount * gridCount;
	float3 offset = 0;

	for (int z = -1; z <= 1; z++)
	{
		for (int y = -1; y <= 1; y++)
		{
			for (int x = -1; x <= 1; x++)
			{
				int pos_z = gridPos.z + z;
				int pos_y = gridPos.y + y;
				int pos_x = gridPos.x + x;
				offset.x = 0;
				offset.y = 0;
				offset.z = 0;

				if (pos_x < 0)
				{
					pos_x = gridCount - 1;
					offset.x = -inResolution;
				}

				if (pos_x >= gridCount)
				{
					pos_x = 0;
					offset.x = inResolution;
				}

				if (pos_y < 0)
				{
					pos_y = gridCount - 1;
					offset.y = -inResolution;
				}

				if (pos_y >= gridCount)
				{
					pos_y = 0;
					offset.y = inResolution;
				}

				if (pos_z < 0)
				{
					pos_z = gridCount - 1;
					offset.z = -inResolution;
				}

				if (pos_z >= gridCount)
				{
					pos_z = 0;
					offset.z = inResolution;
				}

				result[index] = samplePoints[pos_x + pos_y * gridCount + pos_z * offset_z] + offset;
				index++;
			}
		}
	}
}

float getCloseDistance(in int3 n27[27], in int3 pos)
{
	float result = FloatMax;

	for (int i = 0; i < 27; i++)
	{
		float dis = distance(n27[i], pos);
		if (dis < result)
		{
			result = dis;
		}
	}

	return result;
}

float getNoiseF(in StructuredBuffer<int3> samplePoints, float3 pos
	, in int gridCount, in int gridLength, in float gridRate)
{
	pos.x = pos.x - (int)pos.x;
	pos.y = pos.y - (int)pos.y;
	pos.z = pos.z - (int)pos.z;

	if (pos.x < 0.0f)
	{
		pos.x = 1.0f + pos.x;
	}

	if (pos.y < 0.0f)
	{
		pos.y = 1.0f + pos.y;
	}

	if (pos.z < 0.0f)
	{
		pos.z = 1.0f + pos.z;
	}


	int3 grid_pos = getGridF(pos, gridRate);
	int3 n27[27];
	getNeighbour27(samplePoints, grid_pos, gridCount, n27);

	int3 cp = int3(pos.x * inResolution, pos.y * inResolution, pos.z * inResolution);

	if (inFlip)
	{
		return 1.0f - getCloseDistance(n27, cp) / gridLength;
	}

	return getCloseDistance(n27, cp) / gridLength;
}

float remap(float originalValue, float originalMin, float originalMax, float newMin, float newMax)
{
	return newMin + (saturate((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));
}

float calculateWorleyNoise(in StructuredBuffer<int3> samplePoints
	, float3 pos, float freq, int octave
	, int gridCount, int gridLength, float gridRate)
{
	float strength = 1.0f;
	float sum_strength = 1.0f;
	float noise = 0;
	for (int o = 0; o < octave; o++)
	{
		noise += getNoiseF(samplePoints, pos * freq + inOffset
			, gridCount, gridLength, gridRate) * strength;
		freq *= 2.0f;
		strength *= 0.5f;
		sum_strength += strength;
	}

	noise /= sum_strength;

	return noise;
}

float calculatePerlinNoise(float3 pos)
{
	float freq = inFrequency;
	float strength = 1.0f;
	float sum_strength = strength;
	float perlin = snoise(pos * freq + inOffset) * strength;
	for (int o = 1; o < inOctave; o++)
	{
		freq *= inLacunarity;
		strength *= inPersistence;
		sum_strength += strength;
		perlin += snoise(pos * freq + inOffset) * strength;
	}

	perlin /= sum_strength;

	return (perlin + 1.0) * 0.5f;
}

[numthreads(8, 8, 2)]
void main3D(uint3 id : SV_DispatchThreadID)
{
	float3 pos = float3
		(id.x / (float)inResolution - 0.5f
			, id.y / (float)inResolution - 0.5f
			, id.z / (float)inResolution - 0.5f);

	float worley00 = calculateWorleyNoise(inSamplePoint3D0, pos
		, 1, 1
		, 4, inResolution / 4, 1.0 / 4);

	float worley01 = calculateWorleyNoise(inSamplePoint3D1, pos
		, 1, 1
		, 8, inResolution / 8, 1.0 / 8);

	float worley02 = calculateWorleyNoise(inSamplePoint3D2, pos
		, 1, 2
		, 16, inResolution / 16, 1.0 / 16);

	float worley03 = calculateWorleyNoise(inSamplePoint3D3, pos
		, 1, 3
		, 32, inResolution / 32, 1.0 / 32);

	float perlin = calculatePerlinNoise(pos);

	float perlin_worley = remap(perlin, worley00, 1.0f, 0.0f, 1.0f);

	outShapeTex3D[id] = float4(perlin_worley, worley01, worley02, worley03);
	outShapePerlinNoiseTex3D[id] = perlin;
}